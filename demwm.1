.TH "DEMWM" "1" 
.SH "NAME"
.PP
demwm - Dynamic Explosion-Mental’s Window Manager
.SH "SYNOPSIS"
.PP
\fBdemwm\fP [ -v ]
.SH "DESCRIPTION"
.PP
A custom fork of dwm(1), a (tiling) window manager for X. You have customs \fBrules\fP and \fBlayouts\fP to use and set that handles clients in different ways.


.PP
Windows are grouped by tags. Each window can be tagged with one or multiple tags. Selecting certain tags displays all windows with these tags.


.PP
Each monitor has it’s own set of tags and therefore, one window can only belong to one monitor; meaning you can’t view the same window in two different \fBindependent\fP monitors, of course this is possible if you mirror in between outputs (monitors).


.PP
The status bar text is filled with command outputs (stdout) defined in config.h. \fBdemwm\fP will use the greatest common divisor of the \fBinterval\fP value of the \fBblocks\fP array to have a constant value in order to call and update blocks that need it, so keep an eye on this. This will only display on the selected monitor.
.SH "OPTIONS"
.TP
\fB-v\fP
Print the version number and exit.
.SH "SIGNALS"
.SS "SIGHUP - 1"
.PP
Restart the dwm process.
.SS "SIGTERM - 15"
.PP
Cleanly terminate the dwm process.
.SH "CONFIGURATION"
.PP
dwm is customized by creating a custom config.h and (re)compiling the source code. This keeps it simple, since reading a config file isn’t that hard (but adds unneeded complexity), and in many aspects more customizable. I try my best to comment about the variables in config.h, since they don’t do anything crazy, so it should be very straight foward what does what.


.PP
What do you need to know? User functions, described below.


.PP
\fINOTE\fP: Function that do take an argument, are bidirectional: this means that number signs define the behaviour of the function. ( \fC\-1\fP / \fC+1\fP )
.SH "FUNCTIONS"
.SS "cyclelayout"
.PP
Moves the layouts index depending on the argument. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "combotag"
.PP
Select multiple tags to \fCtag\fP by pressing all the right keys as a combo: you can press multiple tags by holding the modifier(s) keys (MOD by default). 
.br

.PP
Takes an (unsigned) int which indicates the tag as an exponent of \fC2\fP. Just define it as \fC1 << TAG\fP where TAG is the tag you wish (starting from 0).
.SS "comboview"
.PP
Select multiple tags to \fCview\fP by pressing all the right keys as a combo: you can press multiple tags by holding the modifier(s) keys (MOD by default). 
.br

.PP
Takes an (unsigned) int which indicates the tag as an exponent of \fC2\fP. Just define it as \fC1 << TAG\fP where TAG is the tag you wish (starting from 0).
.SS "defaultgaps"
.PP
Set the gaps to the values defined in config.h. 
.br

.PP
No arguments.
.SS "focusmon"
.PP
Focus monitor 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "focusstack"
.PP
More like, ’focus client’. Focuses the next/prev client (window). 
.br

.PP
Takes an \fIinteger\fP as an argument.
.SS "incnmaster"
.PP
Increase master, sutracts/adds the first stack (slave) window to the master stack (left side on default tile layout). 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "incrgaps"
.PP
Increases or decreses \fBinner\fP, \fBouter\fP, \fBvertical\fP and \fBhorizontal\fP gaps by the argument given. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "incrigaps"
.PP
Increases or decreses the \fBinner\fP, \fBvertical\fP and \fBhorizontal\fP gaps by the argument given. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "incrihgaps"
.PP
Increases or decreses the \fBinner\fP, and \fBhorizontal\fP gaps by the argument given. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "incrivgaps"
.PP
Increases or decreses the \fBinner\fP and \fBvertical\fP gaps by the argument given. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "incrogaps"
.PP
Increases or decreses the \fBouter\fP, \fBvertical\fP and \fBhorizontal\fP gaps by the argument given. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "incrohgaps"
.PP
Increases or decreses the \fBouter\fP, and \fBhorizontal\fP gaps by the argument given. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "incrovgaps"
.PP
Increases or decreses the \fBouter\fP and \fBvertical\fP gaps by the argument given. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "killclient"
.PP
The name describe it, kills a window client. 
.br

.PP
No arguments.
.SS "movefh\d\s-2setmfact\s+2\u"
.PP
A custom fuction of mine which reuses two functions: \fBmovefloathoriz\fP and \fBsetmfact\fP
This is just because setmfact has no effect if I have a floating window. 
.br

.PP
It takes an \fIfloat\fP argument and passes it to \fCsetmfact\fP. The argument for the \fCmovefloathoriz\fP is defined in config.h as the variable \fCmovefloat\fP.
.SS "movefloathorz"
.PP
Moves the current \fBfloating\fP windows horizontaly by the argument given. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "movefloatvert"
.PP
Moves the current \fBfloating\fP windows verticaly by the argument given. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "movefv\d\s-2pushstack\s+2\u"
.PP
A custom fuction of mine which reuses two functions: \fBmovefloatvert\fP and \fBpushstack\fP
This is just because \fBpushstack\fP has no effect if I have a floating window. 
.br

.PP
It takes an \fIinteger\fP argument and passes it to \fCpushstack\fP. The argument for the \fCmovefloatvert\fP is defined in config.h as the variable \fCmovefloat\fP.
.SS "pushstack"
.PP
\fIPushes\fP the current client to be the next/previous client in the stack. 
.br
Note: Currently with this function the client can become the master, this is not intended since for this we have \fBzoom\fP. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "quit"
.PP
Quits demwm. 
.br

.PP
No arguments.
.SS "refresh"
.PP
Restarts or refreshes the current \fBdemwm\fP instance.
This keeps all clients into their tags and corresponding monitors, as well as leaves the clients in a floating state and fullscreened, in case they have that property.
This won’t keep the layouts of the tags, the state of gaps (enabled/disabled), master/slaves relations, etc. If you wish these \fIworkspace\fP like feature, checkout dusk(1). 
.br

.PP
No arguments.
.SS "scratchpad\d\s-2hide\s+2\u"
.PP
Adds the current client to the \fBdynamic\fP scratchpads list, hiding it. See SCRATCHPADS section. 
.br

.PP
No arguments.
.SS "scratchpad\d\s-2remove\s+2\u"
.PP
Removes the current client to the \fBdynamic\fP scratchpads list. See SCRATCHPADS section. 
.br

.PP
No arguments.
.SS "scratchpad\d\s-2show\s+2\u"
.PP
Show a dynamic scratchpad from the list. If more than one window exist in the list, this functions cycles between them from first to last added. See SCRATCHPADS section. 
.br

.PP
No arguments.
.SS "setmfact"
.PP
\fBSets\fP the \fBmaster\fP \fBfactor\fP area, modifies the \fCmfact\fP (master factor area) value at runtime. 
.br

.PP
It takes an \fIfloat\fP argument, usually less than \fC1\fP.
.SS "shiftboth"
.PP
\fCshiftview\fP + \fCshifttag\fP 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "shifttag"
.PP
\fCtag\fP the current window to the next/previous \fIN\fP tag. \fIN\fP being defined by the argument. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "shifttagclients"
.PP
\fCtag\fP the current window to the next/previous \fIN\fP \fBoccupied\fP tag, a tag with at least one client. \fIN\fP being defined by the argument. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "shiftview"
.PP
\fCview\fP the current window to the next/previous \fIN\fP tag. \fIN\fP being defined by the argument. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "shiftviewclients"
.PP
\fCview\fP the current window to the next/previous \fIN\fP \fBoccupied\fP tag, a tag with at least one client. \fIN\fP being defined by the argument. 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "spawn"
.PP
A wrapper for \fIexec\fP function. This executes shell commands. 
.br

.PP
It takes a \fIvoid\fP argument: an array of chars with a last element of \fBNULL\fP. The wrapper macro \fBSHCMD\fP sets \fC/bin/sh \-c\fP as the command, which allows you to do shell tricks (\fC&&\fP, \fC||\fP, \fC&\fP, etc)
.SS "tag"
.PP
“\fItag\fP” the current window to a tag. Basically like moving the windows to a ’workspace’ or a “\fIdifferent desktop\fP”, which is only a way of thinking since dwm doesn’t implements those.

.PP
Takes an (unsigned) int which indicates the tag as an exponent of \fC2\fP. Just define it as \fC1 << TAG\fP where TAG is the tag you wish (starting from 0).
.SS "tagmon"
.PP
Like \fCtag\fP but to the other monitor. Sends the window to the next monitor (display 0, 1, etc..). 
.br

.PP
It takes an \fIinteger\fP argument.
.SS "togglealwaysontop"
.PP
Add or remove the \fIalwaysontop\fP state of a client. \fBAlwaysontop\fP means to be on top of all windows (including the bar), useful when combined with the sticky flag. 
.br

.PP
No arguments.
.SS "togglebar"
.PP
(Un)hides the bar. 
.br

.PP
No arguments.
.SS "togglefakefullscreen"
.PP
Add or remove the \fIfakefullscreen\fP state property of the client. \fBFakeFullScreen\fP means to have the window in a fullscreen state, in a window basis, but treat it as a normal window, in a window manager basis. This results in having fullscreened windows that can be tiled, floating, etc. and the window doesn’t necessarily occupies the hole screen. 
.br

.PP
No arguments.
.SS "togglefloating"
.PP
Toggles floating behaviour on windows. This depends on the current state of the window. 
.br

.PP
No arguments.
.SS "togglefullscreen"
.PP
Add or remove the \fIfullscreen\fP state property of the client. 
.br

.PP
No arguments.
.SS "togglestatus"
.PP
(Un)hides the status text blocks, keeping the bar up if active. 
.br

.PP
No arguments.
.SS "togglesticky"
.PP
Add or remove the \fIsticky\fP state of a client. \fBSticky\fP means that the window will be visible in all tags. 
.br

.PP
No arguments.
.SS "toggletag"
.PP
Like tag but it can stack, meaning you can ’tag’ multiple tags. This is toggleable. 
.br

.PP
Takes an (unsigned) int which indicates the tag as an exponent of \fC2\fP. Just define it as \fC1 << TAG\fP where TAG is the tag you wish (starting from 0).
.SS "toggletopbar"
.PP
Inverse the position of the bar. If the bar is on the top, puts it on the bottom; if the bar is on the bottom, puts it on the top. 
.br

.PP
No arguments.
.SS "togglevacant"
.PP
(Un)hides the vacant (empty) tags. 
.br

.PP
No arguments.
.SS "toggleview"
.PP
Like view but it can stack, meaning you can ’view’ multiple tags. This is toggleable. 
.br

.PP
Takes an (unsigned) int which indicates the tag as an exponent of \fC2\fP. Just define it as \fC1 << TAG\fP where TAG is the tag you wish (starting from 0).
.SS "updateblock"
.PP
updates a status bar block text. 
.br

.PP
It takes an (unsigned) \fIinteger\fP argument, which correspond to the signal number of the block you wish to update. 
.br

.PP
\fINote\fP: Since the blocks updates are asynchronous (in the background), the signaling is ’instantaneous’. Say you have a same keybinding that executes some command related to the status block, and you also define the same keybinding to update the block using this function; most likely updating the block will be faster and thus the block will not be affected by the other command.
.SS "view"
.PP
View the contents of a tag, you can think of it like moving to a tag. 
.br

.PP
Takes an (unsigned) int which indicates the tag as an exponent of \fC2\fP. Just define it as \fC1 << TAG\fP where TAG is the tag you wish (starting from 0).
.SS "xrdb"
.PP
Refreshes or reloads the colors, reads their Xresource value and arranges all the monitors (which actually displays the new colors, if any). 
.br

.PP
No arguments.
.SS "zoom"
.PP
Swaps between the first window on the master stack to the current window. If you are already on the first master window, it uses the second master window. 
.br

.PP
No arguments.
.SS "zoomswap"
.PP
Variation of the \fCzoom\fP function that maintains the positions of the windows. 
.br

.PP
No arguments.
.SH "SCRATCHPADS"
.PP
I have two patches: \fIscratchpads\fP and \fIdynamic scratchpads\fP. Both of these do different functions so they work well so here goes a bit of explanation:
.SS "dynamic scratchpads"
.PP
Any window can be added or removed as a scratchpad. You can add multiple clients to this “\fIlist\fP” of dynamic scratchpads but the catch is that to get to a certain client the binding will cycle through them (meaning more key presses).
.SS "static scratchpads"
.PP
Allows you  to \fIstore\fP a client on a tag that isn’t visible. When you call that client by pressing a keybinding you basically \fCtoggleview\fP that tag and you will see the client store. This scratchpad can be maintained (called) between multiple monitors. 
.br

.PP
For this you need to define a \fCRule\fP for that client (res name or class) and add it to the tag \fCSP(X)\fP, which X represents the same index in the array of the \fCscratchpads\fP array. For simpler understanding just use the sample variables I defined which are \fCSp1\fP to \fCSp9\fP and make sure these match in between the \fCRule\fP tags, the binding and the definition of the command inside the array \fCscratchpads\fP.
.SH "EXAMPLES"
.SS "Usage of \fCspawn\fP and \fCSHCMD\fP"
.RS
.nf
\fCstatic const char *ncmpcpp[] = { "st", "-e", "ncmpcpp", NULL };
static Key keys[] = {
	/* modifier(s)      key         function        argument        */
	{ MODKEY            XK_n,       spawn,      { .v = ncmpcpp }    },
	{ MODKEY            XK_m,       SHCMD("st -e ncmpcpp")          },
   ...
};
\fP
.fi
.RE
.SS "Defining a \fBstatic\fP scratchpad"
.RS
.nf
\fCstatic const Rule rules[] = {
  	RULE(.instance = "term", .tags = SPTAG(Sp1))
    ...
};
static const char *scratchpads[][32] = {
[Sp1] = { "st", "-n", "term", NULL }, /* terminal */
...
};
static const Key keys[] = {
	SPKEYS(MOD,		XK_s,      Sp1)
    ...
};
\fP
.fi
.RE
.SH "ISSUES"
.PP
Java applications which use the XToolkit/XAWT backend may draw grey windows
only. The XToolkit/XAWT backend breaks ICCCM-compliance in recent JDK 1.5 and
early JDK 1.6 versions, because it assumes a reparenting window manager.
Possible workarounds are using JDK 1.4 (which doesn’t contain the XToolkit/XAWT
backend) or setting the environment variable \fCAWT_TOOLKIT=MToolkit\fP (to use the
older Motif backend instead) or running \fCxprop \-root \-f _NET_WM_NAME 32a \-set
_NET_WM_NAME LG3D\fP or \fCwmname LG3D\fP (to pretend that a non-reparenting window
manager is running that the XToolkit/XAWT backend can recognize) or when using
OpenJDK setting the environment variable \fC_JAVA_AWT_WM_NONREPARENTING=1\fP
.SH "SEE ALSO"
.PP
dwm(1)
.SH "BUGS"
.PP
\fIhttps://github.com/explosion-mental/demwm\fP 
.br
\fIhttps://codeberg.org/explosion-mental/demwm\fP
